Objective: To implement and analyze GREEDY AND DYNAMIC approaches for solving Knapsack problem and compare their time and space complexities (through graph) Write algorithms also for each version.  4a. Fractional knapsack Problem 4b. 0/1 Knapsack Problem

Ans: 4a. Fractional knapsack Problem
Algorithm Steps:
1.	Calculate profit/weight ratio for each item.
2.	Sort items in descending order of ratio.
3.	Initialize totalProfit = 0 and currentWeight = 0.
4.	For each item in sorted order:
•	If item fits completely, add its profit.
•	Else, take the fraction that fits and add fractional profit.
5.	Stop when knapsack is full.

Time Complexity: O(n log n) (due to sorting)
Space Complexity: O(n) (for storing items and ratios)
Ans: 4b. 0/1 Knapsack Problem
Problem
•	Items cannot be broken.
•	Goal: Maximize profit with weight ≤ capacity.

Dynamic Programming Algorithm (0/1 Knapsack)

Algorithm Steps:
1.	Let dp[i][w] = maximum profit using first i items with max weight w.
2.	Initialize dp[0][w] = 0 for all w.
3.	For each item i (1 to n):
•	For each weight w (0 to capacity):
•	If weight[i] <= w:
dp[i][w] = max(profit[i] + dp[i-1][w-weight[i]], dp[i-1][w])
•	Else:
dp[i][w] = dp[i-1][w]
4.	dp[n][capacity] is the maximum profit.

Time Complexity: O(ncapacity)
Space Complexity: O(ncapacity)
Code in c to compare between time complexity of both:
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

struct Item {
int weight, profit;
float ratio;
};

// Greedy Fractional Knapsack
float fractionalKnapsack(struct Item items[], int n, int capacity) {
// Calculate ratio
for(int i=0; i<n; i++)
items[i].ratio = (float)items[i].profit / items[i].weight;

// Sort items by ratio descending
for(int i=0; i<n-1; i++) {
for(int j=i+1; j<n; j++) {
if(items[i].ratio < items[j].ratio) {
struct Item temp = items[i];
items[i] = items[j];
items[j] = temp;
}
}
}

float totalProfit = 0;
int w = 0;
for(int i=0; i<n; i++) {
if(w + items[i].weight <= capacity) {
w += items[i].weight;
totalProfit += items[i].profit;
} else {
int remain = capacity - w;
totalProfit += items[i].profit * ((float)remain / items[i].weight);
break;
}
}
return totalProfit;
}

// 0/1 Knapsack using 1D DP
int knapsackDP(int weight[], int profit[], int n, int capacity) {
int *dp = (int *)calloc(capacity + 1, sizeof(int));
for(int i=0; i<n; i++) {
for(int w=capacity; w>=weight[i]; w--) {
if(dp[w] < profit[i] + dp[w - weight[i]])
dp[w] = profit[i] + dp[w - weight[i]];
}
}
int result = dp[capacity];
free(dp);
return result;
}

int main() {
int n = 1000; // number of items
int capacity = 4000; // knapsack capacity
struct Item items[n];
int weight[n], profit[n];

// Generate random items
srand(time(NULL));
for(int i=0; i<n; i++) {
items[i].weight = weight[i] = rand() % 50 + 1;
items[i].profit = profit[i] = rand() % 100 + 1;
}

// Measure Greedy time
clock_t start = clock();
float greedyProfit = fractionalKnapsack(items, n, capacity);
clock_t end = clock();
double greedyTime = (double)(end - start) / CLOCKS_PER_SEC;

// Measure DP time
start = clock();
int dpProfit = knapsackDP(weight, profit, n, capacity);
end = clock();
double dpTime = (double)(end - start) / CLOCKS_PER_SEC;

printf("Fractional Knapsack Profit = %.2f, Time = %.6f seconds\n", greedyProfit, greedyTime);
printf("0/1 Knapsack Profit = %d, Time = %.6f seconds\n", dpProfit, dpTime);

return 0; 


